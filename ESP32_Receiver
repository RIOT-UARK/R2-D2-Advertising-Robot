 //TODO: After controller is turned off, channel values MUST return to default. This could be a safety issue

// This code recieves PWM channels from the radio receiver and will be able to send PWM signals to the motor controllers of 
// the bot. This microcontroller is necessary due to having different 'modes' of operation. I.e.: Moving forward requires 
// sending a positive value to both the left and right drive motors. Turning the bot would then require sending a positive
// value to only one controller. 

//TODO: Implement the following modes controlled by Switches 7-10: Drive, Dome rotation, emote, etc.
#include <esp_now.h>
#include <WiFi.h>

// Reciever to ESP32 pinout
#define CH1 2
#define CH2 4
#define CH3 16
#define CH4 17
#define CH5 5
#define CH6 18
#define CH7 19
#define CH8 21
#define CH9 22
#define CH10 23

//ESP32 to Motor Controllers pinout
#define LEFTDRIVE 25
#define RIGHTDRIVE 26
#define DOMEMOTOR 27
#define MOTOR4 32


uint8_t broadcastAddress[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

//Create a struct that holds the ESP NOW packets
typedef struct struct_message {
    String recip;
    int a;
} struct_message;

//packet to send
struct_message packet;
//packet that is received
struct_message incomingReadings;

esp_now_peer_info_t peerInfo;

//Callback function when data is received
void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {
  memcpy(&packet, incomingData, sizeof(packet));

    //This Receiver microcontroller will be receiving data from the computer vision Camera.
    //Todo: add code to receive input packets from the camera and send commands to the Dome motor. 
}
//Callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}


// Ints to represent values from sticks and pots
int ch1Value, ch2Value, ch3Value, ch4Value, ch5Value, ch6Value;

// Bool to represent switch value
bool ch7Value;
bool ch8Value;
bool ch9Value;
bool ch10Value;

// Ints to be sent to Motor Controllers
int LeftDriveValue, RightDriveValue, DomeMotorValue, Motor4Value;
 

// Read the number of a specified channel and convert to the range provided.
// If the channel is off, return the default value
int readChannel(int channelInput, int minLimit, int maxLimit, int defaultValue){
  int pulseWidth = pulseIn(channelInput, HIGH, 30000);                                    //int pulseWidth = pulseiIn(pin, HIGH/LOW, timeout)
  if (pulseWidth < 100) return defaultValue;
  return map(pulseWidth, 1000, 2000, minLimit, maxLimit);
}
 
// Read the switch channel and return a boolean value
bool readSwitch(byte channelInput, bool defaultValue){
  int intDefaultValue = (defaultValue)? 100: 0;
  int pulseWidth = readChannel(channelInput, 0, 100, intDefaultValue);
  return (pulseWidth > 50);
}
 
void setup(){
  // Set up serial monitor
  Serial.begin(19200);
  
    WiFi.mode(WIFI_STA);

    if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  //Register callback functions
  esp_now_register_send_cb(OnDataSent);
  esp_now_register_recv_cb(OnDataRecv);

  //Register peer network
  memcpy(peerInfo.peer_addr, broadcastAddress, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;

  //Add peer network
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
  
  // Set all pins as inputs
  pinMode(CH1, INPUT);
  pinMode(CH2, INPUT);
  pinMode(CH3, INPUT);
  pinMode(CH4, INPUT);
  pinMode(CH5, INPUT);
  pinMode(CH6, INPUT);
  pinMode(CH7, INPUT);
  pinMode(CH8, INPUT);
  pinMode(CH9, INPUT);
  pinMode(CH10, INPUT);

  //Figure out the correct PWM frequencies and set up the output pins with
  // ledcSetup(ledChannel, freq, resolution); and
  // ledcAttachPin(ledPin, ledChannel);

  //As of now, the only recipient of messages from this board will be the Audio board.
  packet.recip = "audi";
}
 
 
void loop() {

  
  // Get values for each channel
  ch1Value = readChannel(CH1, -100, 100, 0);
  ch2Value = readChannel(CH2, -100, 100, 0);
  ch3Value = readChannel(CH3, -100, 100, -100);
  ch4Value = readChannel(CH4, -100, 100, 0);
  ch5Value = readChannel(CH5, -100, 100, 0);
  ch6Value = readChannel(CH6, -100, 100, 0);
  ch7Value = readSwitch(CH7, false);
  ch8Value = readSwitch(CH8, false);
  ch9Value = readSwitch(CH9, false);
  ch10Value = readSwitch(CH10, false);

  if (ch7Value == 0 && ch8Value == 0 && ch9Value == 0 && ch10Value == 0) {       //DRIVE MODE
    //Channel 3 --> Forwards/Backwards (LMotor + RMotor) 
    //Channel 1 --> Turn Left/Right (Either -LMotor/+RMotor or just +1Motor forward )
    
    if (abs(ch1Value) < 10) { // If left stick not being pressed
      //ledcWrite(ledChannel, dutyCycle);
    }
    else {

    }
  }

    if (ch7Value == 1 && ch8Value == 0 && ch9Value == 0 && ch10Value == 0) {       //DOME ROTATION MODE
    //Channel 1 --> Turn Dome Left/Right
  }

      if (ch7Value == 0  && ch8Value == 1 && ch9Value == 0 && ch10Value == 0) {       //EMOTE MODE
    //Move joysticks all the way to one direction to trigger an emote.
    //Break emote functions out into functions above the main loop

    //if emote 'a' is selected -> packet.a = 2;
    //then -> esp_now_send(broadcastAddress, (uint8_t *) &packet, sizeof(packet));
  }

  //Room for 2 more 'modes' 


  // Print to Serial Monitor
  Serial.print("Ch1: ");
  Serial.print(ch1Value);
  Serial.print(" | Ch2: ");
  Serial.print(ch2Value);
  Serial.print(" | Ch3: ");
  Serial.print(ch3Value);
  Serial.print(" | Ch4: ");
  Serial.print(ch4Value);
  Serial.print(" | Ch5: ");
  Serial.print(ch5Value);
  Serial.print(" | Ch6: ");
  Serial.print(ch6Value);
  Serial.print(" | Ch7: ");
  Serial.print(ch7Value);
  Serial.print(" | Ch8: ");
  Serial.print(ch8Value);
  Serial.print(" | Ch9: ");
  Serial.print(ch9Value);
  Serial.print(" | Ch10: ");
  Serial.println(ch10Value);
  
}
